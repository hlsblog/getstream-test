<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stream Feeds - ç”¨æˆ·ç•Œé¢</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .user-setup {
            padding: 30px;
            border-bottom: 1px solid #eee;
            background: #f8f9fa;
        }

        .user-setup h2 {
            margin-bottom: 20px;
            color: #333;
            font-size: 1.5rem;
        }

        .input-group {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .input-group label {
            font-weight: 600;
            color: #555;
            min-width: 80px;
        }

        .input-group input {
            flex: 1;
            min-width: 200px;
            padding: 12px 16px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        .input-group input:focus {
            outline: none;
            border-color: #4facfe;
            box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-decoration: none;
            display: inline-block;
            text-align: center;
        }

        .btn-primary {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(79, 172, 254, 0.3);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
            transform: translateY(-2px);
        }

        .main-content {
            padding: 30px;
        }

        .feed-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .feed-tab {
            padding: 12px 24px;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        .feed-tab.active {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border-color: #4facfe;
        }

        .feed-tab:hover:not(.active) {
            border-color: #4facfe;
            background: #f8f9fa;
        }

        .post-form {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 30px;
            border: 1px solid #eee;
        }

        .post-form h3 {
            margin-bottom: 20px;
            color: #333;
            font-size: 1.3rem;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
        }

        .form-group textarea {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            font-family: inherit;
            resize: vertical;
            min-height: 100px;
            transition: border-color 0.3s;
        }

        .form-group textarea:focus {
            outline: none;
            border-color: #4facfe;
            box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
        }

        .form-group select {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            background: white;
            transition: border-color 0.3s;
        }

        .form-group select:focus {
            outline: none;
            border-color: #4facfe;
        }

        .post-buttons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .feed-content {
            background: white;
            border-radius: 12px;
            border: 1px solid #eee;
        }

        .feed-header {
            padding: 20px 25px;
            border-bottom: 1px solid #eee;
            background: #f8f9fa;
            border-radius: 12px 12px 0 0;
        }

        .feed-header h3 {
            color: #333;
            font-size: 1.4rem;
            margin-bottom: 5px;
        }

        .feed-info {
            color: #666;
            font-size: 0.9rem;
        }

        .feed-list {
            max-height: 500px;
            overflow-y: auto;
        }

        .feed-item {
            padding: 20px 25px;
            border-bottom: 1px solid #f0f0f0;
            transition: background-color 0.3s;
        }

        .feed-item:hover {
            background: #f8f9fa;
        }

        .feed-item:last-child {
            border-bottom: none;
        }

        .feed-item-content {
            font-size: 16px;
            line-height: 1.5;
            color: #333;
            margin-bottom: 10px;
        }

        .feed-item-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
            color: #666;
        }

        .feed-item-type {
            background: #e9ecef;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: 600;
        }

        .feed-item-time {
            font-style: italic;
        }

        .empty-state {
            text-align: center;
            padding: 60px 25px;
            color: #666;
        }

        .empty-state svg {
            width: 64px;
            height: 64px;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .loading::after {
            content: '';
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #ddd;
            border-top: 2px solid #4facfe;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border: 1px solid #f5c6cb;
        }

        .success {
            background: #d4edda;
            color: #155724;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border: 1px solid #c3e6cb;
        }

        .user-info {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #bbdefb;
        }

        .user-info strong {
            color: #1976d2;
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 12px;
            }

            .header {
                padding: 20px;
            }

            .header h1 {
                font-size: 2rem;
            }

            .user-setup, .main-content {
                padding: 20px;
            }

            .input-group {
                flex-direction: column;
                align-items: stretch;
            }

            .input-group label {
                min-width: auto;
            }

            .feed-controls {
                flex-direction: column;
            }

            .post-buttons {
                flex-direction: column;
            }
        }

        /* ç”¨æˆ·ä¿¡æ¯å’Œå…³æ³¨æŒ‰é’®æ ·å¼ */
        .feed-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #e0e0e0;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .user-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 14px;
        }

        .user-name {
            font-weight: 600;
            color: #333;
            font-size: 14px;
        }

        .follow-btn {
            padding: 4px 12px;
            border: none;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 60px;
        }

        .follow-btn.follow {
            background-color: #1976d2;
            color: white;
        }

        .follow-btn.follow:hover {
            background-color: #1565c0;
            transform: translateY(-1px);
        }

        .follow-btn.unfollow {
            background-color: #f5f5f5;
            color: #666;
            border: 1px solid #ddd;
        }

        .follow-btn.unfollow:hover {
            background-color: #ffebee;
            color: #d32f2f;
            border-color: #d32f2f;
        }

        .bookmark-btn {
            padding: 4px 8px;
            border: none;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 50px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .bookmark-btn.bookmark {
            background-color: #ff9800;
            color: white;
        }

        .bookmark-btn.bookmark:hover {
            background-color: #f57c00;
            transform: translateY(-1px);
        }

        .bookmark-btn.bookmarked {
            background-color: #4caf50;
            color: white;
        }

        .bookmark-btn.bookmarked:hover {
            background-color: #388e3c;
            transform: translateY(-1px);
        }

        .like-btn {
            padding: 4px 8px;
            border: none;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 50px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .like-btn.like {
            background-color: #e91e63;
            color: white;
        }

        .like-btn.like:hover {
            background-color: #c2185b;
            transform: translateY(-1px);
        }

        .like-btn.liked {
            background-color: #f44336;
            color: white;
        }

        .like-btn.liked:hover {
            background-color: #d32f2f;
            transform: translateY(-1px);
        }

        .feed-item-actions {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
        }

        .follow-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }

        /* åˆ†é¡µæ§ä»¶æ ·å¼ */
        .pagination-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            padding: 20px;
            border-top: 1px solid #e9ecef;
            background: #f8f9fa;
            margin-top: 10px;
            border-radius: 0 0 12px 12px;
        }

        .pagination-btn {
            padding: 8px 16px;
            border: 1px solid #ddd;
            background: white;
            color: #333;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            min-width: 80px;
        }

        .pagination-btn:hover:not(:disabled) {
            background: #1976d2;
            color: white;
            border-color: #1976d2;
        }

        .pagination-btn:disabled {
            background: #f5f5f5;
            color: #999;
            cursor: not-allowed;
            border-color: #e0e0e0;
        }

        .pagination-info {
            font-size: 14px;
            color: #666;
            font-weight: 500;
        }

        @media (max-width: 768px) {
            .pagination-controls {
                gap: 10px;
                padding: 15px;
            }

            .pagination-btn {
                padding: 6px 12px;
                font-size: 13px;
                min-width: 70px;
            }
        }

        /* è¯„è®ºç›¸å…³æ ·å¼ */
        .comment-btn {
            padding: 8px 16px;
            border: 1px solid #ddd;
            background: white;
            color: #666;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        .comment-btn:hover {
            background: #f0f0f0;
            border-color: #ccc;
        }

        .comments-section {
            margin-top: 15px;
            padding: 15px;
            background: #f9f9f9;
            border-radius: 8px;
            border: 1px solid #eee;
        }

        .comment-form {
            margin-bottom: 15px;
        }

        .comment-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            font-family: inherit;
            resize: vertical;
            margin-bottom: 10px;
            transition: border-color 0.3s;
        }

        .comment-input:focus {
            outline: none;
            border-color: #4facfe;
            box-shadow: 0 0 0 2px rgba(79, 172, 254, 0.1);
        }

        .comment-submit-btn {
            padding: 8px 16px;
            background: #4facfe;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }

        .comment-submit-btn:hover {
            background: #3d8bfe;
        }

        .comment-submit-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .comments-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .comment-item {
            background: white;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 10px;
            border: 1px solid #eee;
        }

        .comment-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .comment-author {
            font-weight: 600;
            color: #333;
            font-size: 14px;
        }

        .comment-time {
            font-size: 12px;
            color: #999;
        }

        .comment-content {
            color: #555;
            font-size: 14px;
            line-height: 1.4;
            margin-bottom: 8px;
        }

        .comment-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .comment-like-btn {
            padding: 4px 8px;
            border: 1px solid #ddd;
            background: white;
            color: #666;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        .comment-like-btn:hover {
            background: #f0f0f0;
        }

        .comment-like-btn.liked {
            background: #ffe6e6;
            color: #e74c3c;
            border-color: #e74c3c;
        }

        .comment-delete-btn {
            padding: 4px 8px;
            border: 1px solid #ddd;
            background: white;
            color: #999;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        .comment-delete-btn:hover {
            background: #ffe6e6;
            color: #e74c3c;
            border-color: #e74c3c;
        }

        .loading-comments {
            text-align: center;
            color: #999;
            font-size: 14px;
            padding: 20px;
        }

        .no-comments {
            text-align: center;
            color: #999;
            font-size: 14px;
            padding: 20px;
        }

        /* å…³æ³¨åˆ—è¡¨æ ·å¼ */
        .following-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            margin-bottom: 12px;
            background: white;
            transition: all 0.2s ease;
        }

        .following-item:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border-color: #007bff;
        }

        .following-user-info {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
        }

        .following-user-avatar {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 18px;
        }

        .following-user-details {
            flex: 1;
        }

        .following-user-name {
            font-weight: 600;
            color: #333;
            font-size: 16px;
            margin-bottom: 4px;
        }

        .following-user-id {
            color: #666;
            font-size: 14px;
        }

        .following-actions {
            display: flex;
            gap: 8px;
        }

        .unfollow-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s ease;
        }

        .unfollow-btn:hover {
            background: #c82333;
        }

        .no-following {
            text-align: center;
            color: #999;
            font-size: 16px;
            padding: 40px 20px;
        }

        .no-following svg {
            width: 64px;
            height: 64px;
            margin-bottom: 16px;
            opacity: 0.5;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸš€ Stream Feeds</h1>
            <p>ç”¨æˆ·Feedå’ŒForYouæ¨èç®¡ç†ç•Œé¢</p>
        </div>

        <div class="user-setup">
            <h2>ğŸ‘¤ ç”¨æˆ·è®¾ç½®</h2>
            <div class="input-group">
                <label for="userIdInput">ç”¨æˆ·ID:</label>
                <input type="text" id="userIdInput" placeholder="è¯·è¾“å…¥ç”¨æˆ·ID (ä¾‹å¦‚: user123)" value="">
                <button class="btn btn-primary" onclick="setUserId()">è®¾ç½®ç”¨æˆ·</button>
            </div>
        </div>

        <div class="main-content">
            <div id="userInfo" class="user-info" style="display: none;">
                <strong>å½“å‰ç”¨æˆ·:</strong> <span id="currentUserId"></span>
            </div>

            <div id="messageArea"></div>

            <div class="feed-controls">
                <div class="feed-tab active" data-feed="user" onclick="switchFeed('user')">
                    ğŸ“ ç”¨æˆ·Feed (user:<span class="user-id-display"></span>)
                </div>
                <div class="feed-tab" data-feed="foryou" onclick="switchFeed('foryou')">
                    ğŸŒŸ æ¨èFeed (foryou:<span class="user-id-display"></span>)
                </div>
                <div class="feed-tab" data-feed="activities" onclick="switchFeed('activities')">
                    ğŸŒ å…¨å±€æ´»åŠ¨ (activities)
                </div>
                <div class="feed-tab" data-feed="bookmarks" onclick="switchFeed('bookmarks')">
                    â­ æˆ‘çš„æ”¶è— (<span id="bookmarkCount">0</span>)
                </div>
                <div class="feed-tab" data-feed="following" onclick="switchFeed('following')">
                    ğŸ‘¥ æˆ‘çš„å…³æ³¨ (<span id="followingCount">0</span>)
                </div>
                <button class="btn btn-secondary" onclick="refreshCurrentFeed()">ğŸ”„ åˆ·æ–°</button>
            </div>

            <div class="post-form">
                <h3>ğŸ“ å‘å¸ƒæ–°å†…å®¹</h3>
                <div class="form-group">
                    <label for="postContent">å†…å®¹:</label>
                    <textarea id="postContent" placeholder="è¯·è¾“å…¥è¦å‘å¸ƒçš„å†…å®¹..."></textarea>
                </div>
                <div class="form-group">
                    <label for="postTarget">å‘å¸ƒç›®æ ‡:</label>
                    <select id="postTarget">
                        <option value="user">ä»…ç”¨æˆ·Feed</option>
                        <option value="foryou">ä»…ForYouæ¨è</option>
                        <option value="both">åŒæ—¶å‘å¸ƒåˆ°ä¸¤è€…</option>
                    </select>
                </div>
                <div class="post-buttons">
                    <button class="btn btn-primary" onclick="publishPost()">ğŸ“¤ å‘å¸ƒå†…å®¹</button>
                    <button class="btn btn-secondary" onclick="clearPostForm()">ğŸ—‘ï¸ æ¸…ç©º</button>
                </div>
            </div>

            <div class="feed-content">
                <div class="feed-header">
                    <h3 id="feedTitle">ğŸ“ ç”¨æˆ·Feed</h3>
                    <div class="feed-info">
                        <span id="feedInfo">æ˜¾ç¤ºç”¨æˆ·çš„ä¸ªäººåŠ¨æ€</span>
                        <span id="feedCount"></span>
                    </div>
                </div>
                <div id="feedList" class="feed-list">
                    <div class="empty-state">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                        </svg>
                        <p>è¯·å…ˆè®¾ç½®ç”¨æˆ·IDæ¥æŸ¥çœ‹å†…å®¹</p>
                    </div>
                </div>
                
                <!-- åˆ†é¡µæ§ä»¶ -->
                <div id="paginationControls" class="pagination-controls" style="display: none;">
                    <button id="prevPageBtn" class="pagination-btn" onclick="loadPreviousPage()" disabled>
                        â† ä¸Šä¸€é¡µ
                    </button>
                    <span class="pagination-info">
                        <span id="pageInfo">ç¬¬ 1 é¡µ</span>
                    </span>
                    <button id="nextPageBtn" class="pagination-btn" onclick="loadNextPage()" disabled>
                        ä¸‹ä¸€é¡µ â†’
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentUserId = '';
        let currentFeed = 'user';
        
        // åˆ†é¡µç›¸å…³å˜é‡
        let currentPagination = {
            next: null,
            prev: null,
            hasNext: false,
            hasPrev: false
        };
        let currentPageNumber = 1;
        
        // å…³æ³¨çŠ¶æ€ç®¡ç†
        const followingUsers = new Set(); // å­˜å‚¨å½“å‰ç”¨æˆ·å…³æ³¨çš„ç”¨æˆ·åˆ—è¡¨
        
        // æ”¶è—çŠ¶æ€ç®¡ç†
        const bookmarkedActivities = new Set(); // å­˜å‚¨å½“å‰ç”¨æˆ·æ”¶è—çš„æ´»åŠ¨IDåˆ—è¡¨
        
        // ç‚¹èµçŠ¶æ€ç®¡ç†
        const likedActivities = new Set(); // å­˜å‚¨å½“å‰ç”¨æˆ·ç‚¹èµçš„æ´»åŠ¨IDåˆ—è¡¨
        const activityLikeCounts = new Map(); // å­˜å‚¨æ¯ä¸ªæ´»åŠ¨çš„ç‚¹èµæ•°é‡

        // å¸¦è¶…æ—¶çš„fetchå‡½æ•°ï¼ˆ20ç§’è¶…æ—¶ï¼‰
        async function fetchWithTimeout(url, options = {}) {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 20000);
            
            try {
                const response = await fetch(url, {
                    ...options,
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                return response;
            } catch (error) {
                clearTimeout(timeoutId);
                if (error.name === 'AbortError') {
                    throw new Error('è¯·æ±‚è¶…æ—¶ï¼ˆ20ç§’ï¼‰ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–ç¨åé‡è¯•');
                }
                throw error;
            }
        }

        // è®¾ç½®ç”¨æˆ·ID
        async function setUserId() {
            const userIdInput = document.getElementById('userIdInput');
            const userId = userIdInput.value.trim();
            
            if (!userId) {
                showMessage('è¯·è¾“å…¥æœ‰æ•ˆçš„ç”¨æˆ·ID', 'error');
                return;
            }

            try {
                showMessage('æ­£åœ¨è¿æ¥ç”¨æˆ·...', 'loading');
                
                // å¦‚æœå½“å‰æœ‰ç”¨æˆ·è¿æ¥ä¸”ä¸æ˜¯åŒä¸€ä¸ªç”¨æˆ·ï¼Œå…ˆæ–­å¼€è¿æ¥
                if (currentUserId && currentUserId !== userId) {
                    try {
                        await fetchWithTimeout('/api/user/disconnect', { method: 'POST' });
                        console.log('å·²æ–­å¼€ä¹‹å‰çš„ç”¨æˆ·è¿æ¥');
                    } catch (error) {
                        console.warn('æ–­å¼€ä¹‹å‰è¿æ¥æ—¶å‡ºç°è­¦å‘Š:', error);
                    }
                }
                
                // éªŒè¯ç”¨æˆ·è¿æ¥
                const response = await fetchWithTimeout(`/api/user/${userId}/info`);
                const result = await response.json();
                
                if (result.success) {
                    currentUserId = userId;
                    document.getElementById('currentUserId').textContent = userId;
                    document.getElementById('userInfo').style.display = 'block';
                    
                    // æ›´æ–°æ‰€æœ‰ç”¨æˆ·IDæ˜¾ç¤º
                    document.querySelectorAll('.user-id-display').forEach(el => {
                        el.textContent = userId;
                    });
                    
                    showMessage(`ç”¨æˆ· ${userId} è¿æ¥æˆåŠŸï¼`, 'success');
                    
                    // åŠ è½½ç”¨æˆ·å…³æ³¨åˆ—è¡¨
                    await loadFollowingList();
                    
                    // åŠ è½½ç”¨æˆ·æ”¶è—åˆ—è¡¨
                    await loadBookmarksList();
                    
                    // è‡ªåŠ¨åŠ è½½å½“å‰feed
                    await loadFeed(currentFeed);
                } else {
                    throw new Error(result.message || 'ç”¨æˆ·è¿æ¥å¤±è´¥');
                }
            } catch (error) {
                console.error('è®¾ç½®ç”¨æˆ·IDå¤±è´¥:', error);
                showMessage(`è®¾ç½®ç”¨æˆ·å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // åˆ‡æ¢Feedç±»å‹
        async function switchFeed(feedType) {
            if (!currentUserId) {
                showMessage('è¯·å…ˆè®¾ç½®ç”¨æˆ·ID', 'error');
                return;
            }

            currentFeed = feedType;
            
            // æ›´æ–°æ ‡ç­¾çŠ¶æ€
            document.querySelectorAll('.feed-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelector(`[data-feed="${feedType}"]`).classList.add('active');
            
            // æ›´æ–°æ ‡é¢˜å’Œä¿¡æ¯
            const titles = {
                user: 'ğŸ“ ç”¨æˆ·Feed',
                foryou: 'ğŸŒŸ æ¨èFeed',
                activities: 'ğŸŒ å…¨å±€æ´»åŠ¨',
                bookmarks: 'â­ æˆ‘çš„æ”¶è—',
                following: 'ğŸ‘¥ æˆ‘çš„å…³æ³¨'
            };
            const infos = {
                user: 'æ˜¾ç¤ºç”¨æˆ·çš„ä¸ªäººåŠ¨æ€',
                foryou: 'æ˜¾ç¤ºä¸ªæ€§åŒ–æ¨èå†…å®¹',
                activities: 'æ˜¾ç¤ºå…¨å±€æ‰€æœ‰ç”¨æˆ·çš„æ´»åŠ¨',
                bookmarks: 'æ˜¾ç¤ºæˆ‘æ”¶è—çš„æ‰€æœ‰æ´»åŠ¨',
                following: 'æ˜¾ç¤ºæˆ‘å…³æ³¨çš„æ‰€æœ‰ç”¨æˆ·'
            };
            
            document.getElementById('feedTitle').textContent = titles[feedType];
            document.getElementById('feedInfo').textContent = infos[feedType];
            
            // æ§åˆ¶å‘å¸ƒè¡¨å•çš„æ˜¾ç¤º/éšè—
            const postForm = document.querySelector('.post-form');
            if (feedType === 'activities' || feedType === 'bookmarks' || feedType === 'following') {
                postForm.style.display = 'none';
            } else {
                postForm.style.display = 'block';
            }
            
            // é‡ç½®åˆ†é¡µçŠ¶æ€
            resetPagination();
            
            await loadFeed(feedType);
        }

        // åŠ è½½Feedå†…å®¹
        async function loadFeed(feedType, paginationParams = {}) {
            if (!currentUserId) {
                showMessage('è¯·å…ˆè®¾ç½®ç”¨æˆ·ID', 'error');
                return;
            }

            const feedList = document.getElementById('feedList');
            feedList.innerHTML = '<div class="loading">æ­£åœ¨åŠ è½½å†…å®¹...</div>';

            try {
                // æ„å»ºæŸ¥è¯¢å‚æ•°
                const queryParams = new URLSearchParams({
                    limit: '10'
                });
                
                if (paginationParams.next) {
                    queryParams.append('next', paginationParams.next);
                } else if (paginationParams.prev) {
                    queryParams.append('prev', paginationParams.prev);
                }

                let response;
                if (feedType === 'activities') {
                    // å…¨å±€æ´»åŠ¨ä½¿ç”¨ä¸åŒçš„APIç«¯ç‚¹
                    response = await fetchWithTimeout(`/api/activities/${currentUserId}?${queryParams}`);
                } else if (feedType === 'bookmarks') {
                    // æ”¶è—åˆ—è¡¨ä½¿ç”¨æ”¶è—APIç«¯ç‚¹
                    response = await fetchWithTimeout(`/api/user/${currentUserId}/bookmarks?${queryParams}`);
                } else if (feedType === 'following') {
                    // å…³æ³¨åˆ—è¡¨ä½¿ç”¨å…³æ³¨APIç«¯ç‚¹
                    response = await fetchWithTimeout(`/api/user/${currentUserId}/following?${queryParams}`);
                } else {
                    // ç”¨æˆ·feedå’Œforyou feedä½¿ç”¨åŸæœ‰çš„APIç«¯ç‚¹
                    response = await fetchWithTimeout(`/api/feeds/${feedType}/${currentUserId}?${queryParams}`);
                }
                
                const result = await response.json();

                if (result.success) {
                    // æ›´æ–°åˆ†é¡µä¿¡æ¯
                    if (result.data.pagination) {
                        currentPagination = result.data.pagination;
                        updatePaginationControls();
                    }
                    
                    displayFeedContent(result.data);
                } else {
                    throw new Error(result.message || 'åŠ è½½å¤±è´¥');
                }
            } catch (error) {
                console.error('åŠ è½½Feedå¤±è´¥:', error);
                feedList.innerHTML = `
                    <div class="error">
                        <strong>åŠ è½½å¤±è´¥:</strong> ${error.message}
                    </div>
                `;
                // éšè—åˆ†é¡µæ§ä»¶
                document.getElementById('paginationControls').style.display = 'none';
            }
        }

        // æ˜¾ç¤ºFeedå†…å®¹
        function displayFeedContent(data) {
            const feedList = document.getElementById('feedList');
            const feedCount = document.getElementById('feedCount');
            
            // ç‰¹æ®Šå¤„ç†å…³æ³¨åˆ—è¡¨
            if (currentFeed === 'following') {
                displayFollowingList(data);
                return;
            }
            
            feedCount.textContent = `(${data.total} æ¡å†…å®¹)`;

            if (!data.activities || data.activities.length === 0) {
                feedList.innerHTML = `
                    <div class="empty-state">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"/>
                        </svg>
                        <p>æš‚æ— å†…å®¹ï¼Œå¿«æ¥å‘å¸ƒç¬¬ä¸€æ¡åŠ¨æ€å§ï¼</p>
                    </div>
                `;
                return;
            }

            const feedItems = data.activities.map(activity => {
                const time = new Date(activity.created_at).toLocaleString('zh-CN');
                const actorId = activity.user.id || 'unknown';
                const isCurrentUser = actorId === currentUserId;
                
                // ç”Ÿæˆç”¨æˆ·å¤´åƒå­—æ¯ï¼ˆå–ç”¨æˆ·IDçš„ç¬¬ä¸€ä¸ªå­—ç¬¦ï¼‰
                const avatarLetter = actorId.charAt(0).toUpperCase();
                
                // æ£€æŸ¥å…³æ³¨çŠ¶æ€
                const isFollowing = followingUsers.has(actorId);
                const followBtnClass = isFollowing ? 'unfollow' : 'follow';
                const followBtnText = isFollowing ? 'å–æ¶ˆå…³æ³¨' : 'å…³æ³¨';
                
                // æ£€æŸ¥æ”¶è—çŠ¶æ€
                const isBookmarked = bookmarkedActivities.has(activity.id);
                const bookmarkBtnClass = isBookmarked ? 'bookmarked' : 'bookmark';
                const bookmarkBtnText = isBookmarked ? 'â­ å·²æ”¶è—' : 'â˜† æ”¶è—';
                
                // æ£€æŸ¥ç‚¹èµçŠ¶æ€
                const isLiked = likedActivities.has(activity.id);
                const likeBtnClass = isLiked ? 'liked' : 'like';
                const likeBtnText = isLiked ? 'â¤ï¸ å·²ç‚¹èµ' : 'ğŸ¤ ç‚¹èµ';
                const likeCount = activityLikeCounts.get(activity.id) || 0;
                
                return `
                    <div class="feed-item" data-activity-id="${activity.id}">
                        <div class="feed-item-header">
                            <div class="user-info">
                                <div class="user-avatar">${avatarLetter}</div>
                                <span class="user-name">${actorId}</span>
                            </div>
                            ${!isCurrentUser ? `
                                <button class="follow-btn ${followBtnClass}" 
                                        data-user-id="${actorId}" 
                                        onclick="toggleFollow('${actorId}', this)">
                                    ${followBtnText}
                                </button>
                            ` : ''}
                        </div>
                        <div class="feed-item-content">${activity.text || 'æ— æ–‡æœ¬å†…å®¹'}</div>
                        <div class="feed-item-meta">
                            <span class="feed-item-type">${activity.type || 'post'}</span>
                            <span class="feed-item-time">${time}</span>
                        </div>
                        <div class="feed-item-actions">
                            <button class="like-btn ${likeBtnClass}" 
                                    onclick="toggleLike('${activity.id}', this)">
                                ${likeBtnText} ${likeCount > 0 ? `(${likeCount})` : ''}
                            </button>
                            <button class="bookmark-btn ${bookmarkBtnClass}" 
                                    onclick="toggleBookmark('${activity.id}', this)">
                                ${bookmarkBtnText}
                            </button>
                            <button class="comment-btn" onclick="toggleComments('${activity.id}')">
                                ğŸ’¬ è¯„è®º
                            </button>
                        </div>
                        <div class="comments-section" id="comments-${activity.id}" style="display: block;">
                            <div class="comment-form">
                                <textarea class="comment-input" placeholder="å†™ä¸‹ä½ çš„è¯„è®º..." rows="2"></textarea>
                                <button class="comment-submit-btn" onclick="submitComment('${activity.id}')">å‘è¡¨è¯„è®º</button>
                            </div>
                            <div class="comments-list" id="comments-list-${activity.id}">
                                <div class="loading-comments">æ­£åœ¨åŠ è½½è¯„è®º...</div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            feedList.innerHTML = feedItems;
            
            // ç¡®ä¿æ‰€æœ‰å…³æ³¨æŒ‰é’®çŠ¶æ€æ­£ç¡®
            if (data.activities && data.activities.length > 0) {
                // è·å–é¡µé¢ä¸Šæ‰€æœ‰ç”¨æˆ·IDï¼Œå¹¶åŒæ­¥å…¶å…³æ³¨çŠ¶æ€
                const uniqueUserIds = [...new Set(data.activities.map(activity => activity.user.id || 'unknown'))];
                uniqueUserIds.forEach(userId => {
                    if (userId !== currentUserId && userId !== 'unknown') {
                        const isFollowing = followingUsers.has(userId);
                        syncFollowButtonsForUser(userId, isFollowing);
                    }
                });
                
                // ç¡®ä¿æ‰€æœ‰æ”¶è—æŒ‰é’®çŠ¶æ€æ­£ç¡®
                data.activities.forEach(activity => {
                    const isBookmarked = bookmarkedActivities.has(activity.id);
                    syncBookmarkButtonForActivity(activity.id, isBookmarked);
                });
                
                // åŠ è½½å¹¶åŒæ­¥æ‰€æœ‰ç‚¹èµçŠ¶æ€
                loadLikeStatesForActivities(data.activities).then(() => {
                    // ç¡®ä¿æ‰€æœ‰ç‚¹èµæŒ‰é’®çŠ¶æ€æ­£ç¡®
                    data.activities.forEach(activity => {
                        const isLiked = likedActivities.has(activity.id);
                        syncLikeButtonForActivity(activity.id, isLiked);
                    });
                });
                
                // è‡ªåŠ¨åŠ è½½æ‰€æœ‰æ´»åŠ¨çš„è¯„è®ºï¼ˆå› ä¸ºè¯„è®ºåŒºåŸŸé»˜è®¤å±•å¼€ï¼‰
                data.activities.forEach(activity => {
                    loadComments(activity.id);
                });
            }
            
            // æ˜¾ç¤ºåˆ†é¡µæ§ä»¶ï¼ˆå¦‚æœæœ‰å†…å®¹ï¼‰
            const paginationControls = document.getElementById('paginationControls');
            if (data.activities && data.activities.length > 0) {
                paginationControls.style.display = 'flex';
            } else {
                paginationControls.style.display = 'none';
            }
        }

        // æ˜¾ç¤ºå…³æ³¨åˆ—è¡¨
        function displayFollowingList(data) {
            const feedList = document.getElementById('feedList');
            const feedCount = document.getElementById('feedCount');
            
            // æ›´æ–°å…³æ³¨æ•°é‡
            const followingCount = document.getElementById('followingCount');
            const total = data.total || 0;
            feedCount.textContent = `(${total} ä¸ªå…³æ³¨)`;
            followingCount.textContent = total;

            if (!data.following || data.following.length === 0) {
                feedList.innerHTML = `
                    <div class="no-following">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M16 4c0-1.11.89-2 2-2s2 .89 2 2-.89 2-2 2-2-.89-2-2zm4 18v-6h2.5l-2.54-7.63A1.5 1.5 0 0 0 18.54 8H16c-.8 0-1.54.37-2 .97L11.58 11H7c-.8 0-1.54.37-2 .97L2.54 14.37A1.5 1.5 0 0 0 1.12 16H3.5v6h2v-6h2.12l2.5-2.5H12l2.38 2.5H16.5v6h2zm-6.5-10.5c.83 0 1.5-.67 1.5-1.5s-.67-1.5-1.5-1.5-1.5.67-1.5 1.5.67 1.5 1.5 1.5z"/>
                        </svg>
                        <p>æ‚¨è¿˜æ²¡æœ‰å…³æ³¨ä»»ä½•ç”¨æˆ·</p>
                        <p>å»å‘ç°ä¸€äº›æœ‰è¶£çš„ç”¨æˆ·å§ï¼</p>
                    </div>
                `;
                return;
            }

            const followingItems = data.following.map(user => {
                const avatarLetter = user.userId ? user.userId.charAt(0).toUpperCase() : 'U';
                
                return `
                    <div class="following-item" data-user-id="${user.userId}">
                        <div class="following-user-info">
                            <div class="following-user-avatar">${avatarLetter}</div>
                            <div class="following-user-details">
                                <div class="following-user-name">${user.userId}</div>
                                <div class="following-user-id">@${user.userId}</div>
                            </div>
                        </div>
                        <div class="following-actions">
                            <button class="unfollow-btn" onclick="unfollowUser('${user.userId}')">
                                å–æ¶ˆå…³æ³¨
                            </button>
                        </div>
                    </div>
                `;
            }).join('');

            feedList.innerHTML = followingItems;
            
            // éšè—åˆ†é¡µæ§ä»¶ï¼ˆå…³æ³¨åˆ—è¡¨æš‚ä¸æ”¯æŒåˆ†é¡µï¼‰
            const paginationControls = document.getElementById('paginationControls');
            paginationControls.style.display = 'none';
        }

        // å‘å¸ƒå†…å®¹
        async function publishPost() {
            if (!currentUserId) {
                showMessage('è¯·å…ˆè®¾ç½®ç”¨æˆ·ID', 'error');
                return;
            }

            const content = document.getElementById('postContent').value.trim();
            const target = document.getElementById('postTarget').value;

            if (!content) {
                showMessage('è¯·è¾“å…¥è¦å‘å¸ƒçš„å†…å®¹', 'error');
                return;
            }

            try {
                showMessage('æ­£åœ¨å‘å¸ƒå†…å®¹...', 'loading');

                const response = await fetchWithTimeout(`/api/feeds/${target}/${currentUserId}/post`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        text: content,
                        type: target === 'foryou' ? 'recommendation' : 'post'
                    })
                });

                const result = await response.json();

                if (result.success) {
                    showMessage('å†…å®¹å‘å¸ƒæˆåŠŸï¼', 'success');
                    clearPostForm();
                    
                    // åˆ·æ–°å½“å‰æ˜¾ç¤ºçš„feed
                    await loadFeed(currentFeed);
                } else {
                    throw new Error(result.message || 'å‘å¸ƒå¤±è´¥');
                }
            } catch (error) {
                console.error('å‘å¸ƒå¤±è´¥:', error);
                showMessage(`å‘å¸ƒå¤±è´¥: ${error.message}`, 'error');
            }
        }

        // æ¸…ç©ºå‘å¸ƒè¡¨å•
        function clearPostForm() {
            document.getElementById('postContent').value = '';
            document.getElementById('postTarget').value = 'user';
        }

        // åˆ·æ–°å½“å‰Feed
        async function refreshCurrentFeed() {
            if (currentUserId && currentFeed) {
                await loadFeed(currentFeed);
                showMessage('å†…å®¹å·²åˆ·æ–°', 'success');
            }
        }

        // æ˜¾ç¤ºæ¶ˆæ¯
        function showMessage(message, type = 'info') {
            const messageArea = document.getElementById('messageArea');
            
            if (type === 'loading') {
                messageArea.innerHTML = `<div class="loading">${message}</div>`;
                return;
            }
            
            const className = type === 'error' ? 'error' : 'success';
            messageArea.innerHTML = `<div class="${className}">${message}</div>`;
            
            // 3ç§’åè‡ªåŠ¨æ¸…é™¤æ¶ˆæ¯
            setTimeout(() => {
                messageArea.innerHTML = '';
            }, 3000);
        }

        // é¡µé¢åŠ è½½å®Œæˆåçš„åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            // è®¾ç½®é»˜è®¤ç”¨æˆ·IDï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
            const defaultUserId = 'user123';
            document.getElementById('userIdInput').value = defaultUserId;
            
            console.log('ğŸš€ Stream Feeds ç•Œé¢å·²åŠ è½½');
            console.log('ğŸ’¡ æç¤º: è¯·è®¾ç½®ç”¨æˆ·IDå¼€å§‹ä½¿ç”¨');
        });

        // å›è½¦é”®å¿«æ·æ“ä½œ
        document.getElementById('userIdInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                setUserId();
            }
        });

        document.getElementById('postContent').addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && e.ctrlKey) {
                publishPost();
            }
        });

        // åˆ†é¡µç›¸å…³å‡½æ•°
        function updatePaginationControls() {
            const prevBtn = document.getElementById('prevPageBtn');
            const nextBtn = document.getElementById('nextPageBtn');
            const pageInfo = document.getElementById('pageInfo');
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            prevBtn.disabled = !currentPagination.hasPrev;
            nextBtn.disabled = !currentPagination.hasNext;
            
            // æ›´æ–°é¡µé¢ä¿¡æ¯
            pageInfo.textContent = `ç¬¬ ${currentPageNumber} é¡µ`;
        }

        // åŠ è½½ä¸‹ä¸€é¡µ
        async function loadNextPage() {
            if (!currentPagination.hasNext || !currentPagination.next) {
                return;
            }
            
            currentPageNumber++;
            await loadFeed(currentFeed, { next: currentPagination.next });
        }

        // åŠ è½½ä¸Šä¸€é¡µ
        async function loadPreviousPage() {
            if (!currentPagination.hasPrev || !currentPagination.prev) {
                return;
            }
            
            currentPageNumber = Math.max(1, currentPageNumber - 1);
            await loadFeed(currentFeed, { prev: currentPagination.prev });
        }

        // é‡ç½®åˆ†é¡µçŠ¶æ€ï¼ˆåˆ‡æ¢feedç±»å‹æ—¶è°ƒç”¨ï¼‰
        function resetPagination() {
            currentPagination = {
                next: null,
                prev: null,
                hasNext: false,
                hasPrev: false
            };
            currentPageNumber = 1;
            document.getElementById('paginationControls').style.display = 'none';
        }

        // åŒæ­¥æ›´æ–°é¡µé¢ä¸Šæ‰€æœ‰æŒ‡å®šç”¨æˆ·çš„å…³æ³¨æŒ‰é’®çŠ¶æ€
        function syncFollowButtonsForUser(userId, isFollowing) {
            // æŸ¥æ‰¾é¡µé¢ä¸Šæ‰€æœ‰è¯¥ç”¨æˆ·çš„å…³æ³¨æŒ‰é’®
            const userButtons = document.querySelectorAll(`button.follow-btn[data-user-id="${userId}"]`);
            
            userButtons.forEach(button => {
                if (isFollowing) {
                    button.className = 'follow-btn unfollow';
                    button.textContent = 'å–æ¶ˆå…³æ³¨';
                } else {
                    button.className = 'follow-btn follow';
                    button.textContent = 'å…³æ³¨';
                }
                // ç¡®ä¿æŒ‰é’®æ˜¯å¯ç”¨çŠ¶æ€
                button.disabled = false;
            });
            
            console.log(`å·²åŒæ­¥æ›´æ–° ${userButtons.length} ä¸ª ${userId} çš„å…³æ³¨æŒ‰é’®ï¼ŒçŠ¶æ€: ${isFollowing ? 'å·²å…³æ³¨' : 'æœªå…³æ³¨'}`);
        }

        // å…³æ³¨/å–æ¶ˆå…³æ³¨ç”¨æˆ·
        async function toggleFollow(targetUserId, buttonElement) {
            if (!currentUserId) {
                showMessage('è¯·å…ˆè®¾ç½®ç”¨æˆ·ID', 'error');
                return;
            }

            if (targetUserId === currentUserId) {
                showMessage('ä¸èƒ½å…³æ³¨è‡ªå·±', 'error');
                return;
            }

            const isCurrentlyFollowing = followingUsers.has(targetUserId);
            const action = isCurrentlyFollowing ? 'unfollow' : 'follow';
            
            // ç¦ç”¨æŒ‰é’®ï¼Œé˜²æ­¢é‡å¤ç‚¹å‡»
            buttonElement.disabled = true;
            buttonElement.textContent = 'å¤„ç†ä¸­...';

            try {
                let response;
                if (action === 'follow') {
                    response = await fetchWithTimeout(`/api/user/${currentUserId}/follow/${targetUserId}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                } else {
                    response = await fetchWithTimeout(`/api/user/${currentUserId}/follow/${targetUserId}`, {
                        method: 'DELETE',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                }

                const result = await response.json();

                if (result.success) {
                    // æ›´æ–°æœ¬åœ°å…³æ³¨çŠ¶æ€
                    if (action === 'follow') {
                        followingUsers.add(targetUserId);
                        showMessage(`å·²å…³æ³¨ ${targetUserId}`, 'success');
                    } else {
                        followingUsers.delete(targetUserId);
                        showMessage(`å·²å–æ¶ˆå…³æ³¨ ${targetUserId}`, 'success');
                    }
                    
                    // åŒæ­¥æ›´æ–°é¡µé¢ä¸Šæ‰€æœ‰è¯¥ç”¨æˆ·çš„å…³æ³¨æŒ‰é’®
                    syncFollowButtonsForUser(targetUserId, action === 'follow');
                } else {
                    showMessage(result.error || 'æ“ä½œå¤±è´¥', 'error');
                    // æ¢å¤æ‰€æœ‰è¯¥ç”¨æˆ·æŒ‰é’®çš„çŠ¶æ€
                    syncFollowButtonsForUser(targetUserId, isCurrentlyFollowing);
                }
            } catch (error) {
                console.error('å…³æ³¨æ“ä½œå¤±è´¥:', error);
                showMessage('ç½‘ç»œé”™è¯¯ï¼Œè¯·ç¨åé‡è¯•', 'error');
                // æ¢å¤æ‰€æœ‰è¯¥ç”¨æˆ·æŒ‰é’®çš„çŠ¶æ€
                syncFollowButtonsForUser(targetUserId, isCurrentlyFollowing);
            }
        }

        // å–æ¶ˆå…³æ³¨ç”¨æˆ·ï¼ˆä¸“ç”¨äºå…³æ³¨åˆ—è¡¨ï¼‰
        async function unfollowUser(targetUserId) {
            if (!currentUserId) {
                showMessage('è¯·å…ˆè®¾ç½®ç”¨æˆ·ID', 'error');
                return;
            }

            // æ‰¾åˆ°å¯¹åº”çš„æŒ‰é’®å…ƒç´ 
            const followingItem = document.querySelector(`[data-user-id="${targetUserId}"]`);
            const unfollowBtn = followingItem.querySelector('.unfollow-btn');
            
            // ç¦ç”¨æŒ‰é’®ï¼Œé˜²æ­¢é‡å¤ç‚¹å‡»
            unfollowBtn.disabled = true;
            unfollowBtn.textContent = 'å¤„ç†ä¸­...';

            try {
                const response = await fetchWithTimeout(`/api/user/${currentUserId}/follow/${targetUserId}`, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                const result = await response.json();

                if (result.success) {
                    // æ›´æ–°æœ¬åœ°å…³æ³¨çŠ¶æ€
                    followingUsers.delete(targetUserId);
                    showMessage(`å·²å–æ¶ˆå…³æ³¨ ${targetUserId}`, 'success');
                    
                    // ä»å…³æ³¨åˆ—è¡¨ä¸­ç§»é™¤è¯¥é¡¹
                    followingItem.remove();
                    
                    // æ›´æ–°å…³æ³¨æ•°é‡
                    const followingCount = document.getElementById('followingCount');
                    const currentCount = parseInt(followingCount.textContent) || 0;
                    followingCount.textContent = Math.max(0, currentCount - 1);
                    
                    // æ›´æ–°feedè®¡æ•°
                    const feedCount = document.getElementById('feedCount');
                    const newCount = Math.max(0, currentCount - 1);
                    feedCount.textContent = `(${newCount} ä¸ªå…³æ³¨)`;
                    
                    // å¦‚æœæ²¡æœ‰å…³æ³¨çš„ç”¨æˆ·äº†ï¼Œæ˜¾ç¤ºç©ºçŠ¶æ€
                    const feedList = document.getElementById('feedList');
                    if (feedList.children.length === 0) {
                        feedList.innerHTML = `
                            <div class="no-following">
                                <svg viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M16 4c0-1.11.89-2 2-2s2 .89 2 2-.89 2-2 2-2-.89-2-2zm4 18v-6h2.5l-2.54-7.63A1.5 1.5 0 0 0 18.54 8H16c-.8 0-1.54.37-2 .97L11.58 11H7c-.8 0-1.54.37-2 .97L2.54 14.37A1.5 1.5 0 0 0 1.12 16H3.5v6h2v-6h2.12l2.5-2.5H12l2.38 2.5H16.5v6h2zm-6.5-10.5c.83 0 1.5-.67 1.5-1.5s-.67-1.5-1.5-1.5-1.5.67-1.5 1.5.67 1.5 1.5 1.5z"/>
                                </svg>
                                <p>æ‚¨è¿˜æ²¡æœ‰å…³æ³¨ä»»ä½•ç”¨æˆ·</p>
                                <p>å»å‘ç°ä¸€äº›æœ‰è¶£çš„ç”¨æˆ·å§ï¼</p>
                            </div>
                        `;
                    }
                    
                    // åŒæ­¥æ›´æ–°é¡µé¢ä¸Šæ‰€æœ‰è¯¥ç”¨æˆ·çš„å…³æ³¨æŒ‰é’®
                    syncFollowButtonsForUser(targetUserId, false);
                } else {
                    showMessage(result.error || 'å–æ¶ˆå…³æ³¨å¤±è´¥', 'error');
                    // æ¢å¤æŒ‰é’®çŠ¶æ€
                    unfollowBtn.disabled = false;
                    unfollowBtn.textContent = 'å–æ¶ˆå…³æ³¨';
                }
            } catch (error) {
                console.error('å–æ¶ˆå…³æ³¨å¤±è´¥:', error);
                showMessage('ç½‘ç»œé”™è¯¯ï¼Œè¯·ç¨åé‡è¯•', 'error');
                // æ¢å¤æŒ‰é’®çŠ¶æ€
                unfollowBtn.disabled = false;
                unfollowBtn.textContent = 'å–æ¶ˆå…³æ³¨';
            }
        }

        // åŠ è½½ç”¨æˆ·å…³æ³¨åˆ—è¡¨
        async function loadFollowingList() {
            if (!currentUserId) return;

            try {
                const response = await fetchWithTimeout(`/api/user/${currentUserId}/following`);
                const result = await response.json();

                if (result.success && result.data.following) {
                    // æ¸…ç©ºå¹¶é‡æ–°å¡«å……å…³æ³¨åˆ—è¡¨
                    followingUsers.clear();
                    // é€‚é…Stream SDKè¿”å›çš„æ–°æ•°æ®ç»“æ„
                    result.data.following.forEach(followInfo => {
                        // followInfoç°åœ¨æ˜¯å¯¹è±¡ï¼ŒåŒ…å«userId, followedAt, statusç­‰å­—æ®µ
                        const userId = typeof followInfo === 'string' ? followInfo : followInfo.userId;
                        followingUsers.add(userId);
                    });
                    console.log(`å·²åŠ è½½å…³æ³¨åˆ—è¡¨: ${result.data.following.length} ä¸ªç”¨æˆ·`);
                }
            } catch (error) {
                console.error('åŠ è½½å…³æ³¨åˆ—è¡¨å¤±è´¥:', error);
            }
        }

        // æ£€æŸ¥å•ä¸ªç”¨æˆ·çš„å…³æ³¨çŠ¶æ€
        async function checkFollowStatus(targetUserId) {
            if (!currentUserId || targetUserId === currentUserId) return false;

            try {
                const response = await fetchWithTimeout(`/api/user/${currentUserId}/follow/${targetUserId}/status`);
                const result = await response.json();

                if (result.success) {
                    return result.data.isFollowing;
                }
            } catch (error) {
                console.error('æ£€æŸ¥å…³æ³¨çŠ¶æ€å¤±è´¥:', error);
            }
            return false;
        }

        // æ”¶è—/å–æ¶ˆæ”¶è—æ´»åŠ¨
        async function toggleBookmark(activityId, buttonElement) {
            if (!currentUserId) {
                showMessage('è¯·å…ˆè®¾ç½®ç”¨æˆ·ID', 'error');
                return;
            }

            const isCurrentlyBookmarked = bookmarkedActivities.has(activityId);
            const action = isCurrentlyBookmarked ? 'unbookmark' : 'bookmark';
            
            // ç¦ç”¨æŒ‰é’®ï¼Œé˜²æ­¢é‡å¤ç‚¹å‡»
            buttonElement.disabled = true;
            const originalText = buttonElement.textContent;
            buttonElement.textContent = 'å¤„ç†ä¸­...';

            try {
                let response;
                if (action === 'bookmark') {
                    response = await fetchWithTimeout(`/api/user/${currentUserId}/bookmark/${activityId}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                } else {
                    response = await fetchWithTimeout(`/api/user/${currentUserId}/bookmark/${activityId}`, {
                        method: 'DELETE',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                }

                const result = await response.json();

                if (result.success) {
                    // æ›´æ–°æœ¬åœ°æ”¶è—çŠ¶æ€
                    if (action === 'bookmark') {
                        bookmarkedActivities.add(activityId);
                        showMessage('å·²æ”¶è—è¯¥æ´»åŠ¨', 'success');
                    } else {
                        bookmarkedActivities.delete(activityId);
                        showMessage('å·²å–æ¶ˆæ”¶è—', 'success');
                    }
                    
                    // æ›´æ–°æ”¶è—æ•°é‡æ˜¾ç¤º
                    const bookmarkCountElement = document.getElementById('bookmarkCount');
                    if (bookmarkCountElement) {
                        bookmarkCountElement.textContent = bookmarkedActivities.size;
                    }
                    
                    // åŒæ­¥æ›´æ–°é¡µé¢ä¸Šè¯¥æ´»åŠ¨çš„æ”¶è—æŒ‰é’®
                    syncBookmarkButtonForActivity(activityId, action === 'bookmark');
                    
                    // å¦‚æœå½“å‰åœ¨æ”¶è—åˆ—è¡¨é¡µé¢ä¸”å–æ¶ˆäº†æ”¶è—ï¼Œåˆ·æ–°é¡µé¢ä»¥ç§»é™¤è¯¥é¡¹ç›®
                    if (currentFeed === 'bookmarks' && action === 'unbookmark') {
                        setTimeout(() => {
                            loadFeed('bookmarks');
                        }, 500); // å»¶è¿Ÿ500msä»¥ç¡®ä¿ç”¨æˆ·çœ‹åˆ°æˆåŠŸæ¶ˆæ¯
                    }
                } else {
                    showMessage(result.error || 'æ“ä½œå¤±è´¥', 'error');
                    // æ¢å¤æŒ‰é’®çŠ¶æ€
                    syncBookmarkButtonForActivity(activityId, isCurrentlyBookmarked);
                }
            } catch (error) {
                console.error('æ”¶è—æ“ä½œå¤±è´¥:', error);
                showMessage('ç½‘ç»œé”™è¯¯ï¼Œè¯·ç¨åé‡è¯•', 'error');
                // æ¢å¤æŒ‰é’®çŠ¶æ€
                syncBookmarkButtonForActivity(activityId, isCurrentlyBookmarked);
            }
        }

        // åŒæ­¥å•ä¸ªæ´»åŠ¨çš„æ”¶è—æŒ‰é’®çŠ¶æ€
        function syncBookmarkButtonForActivity(activityId, isBookmarked) {
            const buttons = document.querySelectorAll(`[data-activity-id="${activityId}"] .bookmark-btn`);
            buttons.forEach(button => {
                button.disabled = false;
                if (isBookmarked) {
                    button.className = 'bookmark-btn bookmarked';
                    button.innerHTML = 'â­ å·²æ”¶è—';
                } else {
                    button.className = 'bookmark-btn bookmark';
                    button.innerHTML = 'â˜† æ”¶è—';
                }
            });
            
            console.log(`å·²åŒæ­¥æ›´æ–°æ´»åŠ¨ ${activityId} çš„æ”¶è—æŒ‰é’®ï¼ŒçŠ¶æ€: ${isBookmarked ? 'å·²æ”¶è—' : 'æœªæ”¶è—'}`);
        }

        // åŠ è½½ç”¨æˆ·æ”¶è—åˆ—è¡¨
        async function loadBookmarksList() {
            if (!currentUserId) return;

            try {
                const response = await fetchWithTimeout(`/api/user/${currentUserId}/bookmarks`);
                const result = await response.json();

                if (result.success && result.data) {
                    // æ¸…ç©ºå¹¶é‡æ–°å¡«å……æ”¶è—åˆ—è¡¨
                    bookmarkedActivities.clear();
                    const activities = result.data.activities || [];
                    activities.forEach(activity => {
                        // activity.id æ˜¯æ´»åŠ¨ID
                        if (activity && activity.id) {
                            bookmarkedActivities.add(activity.id);
                        }
                    });
                    
                    // æ›´æ–°æ”¶è—æ•°é‡æ˜¾ç¤º
                    const bookmarkCountElement = document.getElementById('bookmarkCount');
                    if (bookmarkCountElement) {
                        bookmarkCountElement.textContent = activities.length;
                    }
                    
                    console.log(`å·²åŠ è½½æ”¶è—åˆ—è¡¨: ${activities.length} ä¸ªæ´»åŠ¨`);
                }
            } catch (error) {
                console.error('åŠ è½½æ”¶è—åˆ—è¡¨å¤±è´¥:', error);
            }
        }

        // æ£€æŸ¥å•ä¸ªæ´»åŠ¨çš„æ”¶è—çŠ¶æ€
        async function checkBookmarkStatus(activityId) {
            if (!currentUserId) return false;

            try {
                const response = await fetchWithTimeout(`/api/user/${currentUserId}/bookmark/${activityId}/status`);
                const result = await response.json();

                if (result.success) {
                    return result.data.isBookmarked;
                }
            } catch (error) {
                console.error('æ£€æŸ¥æ”¶è—çŠ¶æ€å¤±è´¥:', error);
            }
            return false;
        }

        // ç‚¹èµ/å–æ¶ˆç‚¹èµåŠŸèƒ½
        async function toggleLike(activityId, button) {
            if (!currentUserId) {
                showMessage('è¯·å…ˆè®¾ç½®ç”¨æˆ·ID', 'error');
                return;
            }

            if (button.disabled) return;

            const isCurrentlyLiked = likedActivities.has(activityId);
            const action = isCurrentlyLiked ? 'unlike' : 'like';

            // ç¦ç”¨æŒ‰é’®é˜²æ­¢é‡å¤ç‚¹å‡»
            button.disabled = true;

            try {
                let response;
                if (action === 'like') {
                    response = await fetchWithTimeout(`/api/user/${currentUserId}/like/${activityId}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({})
                    });
                } else {
                    response = await fetchWithTimeout(`/api/user/${currentUserId}/like/${activityId}`, {
                        method: 'DELETE'
                    });
                }

                const result = await response.json();

                if (result.success) {
                    // æ›´æ–°æœ¬åœ°ç‚¹èµçŠ¶æ€
                    if (action === 'like') {
                        likedActivities.add(activityId);
                        showMessage('å·²ç‚¹èµè¯¥æ´»åŠ¨', 'success');
                    } else {
                        likedActivities.delete(activityId);
                        showMessage('å·²å–æ¶ˆç‚¹èµ', 'success');
                    }
                    
                    // æ›´æ–°ç‚¹èµæ•°é‡
                    await updateLikeCount(activityId);
                    
                    // åŒæ­¥æ›´æ–°é¡µé¢ä¸Šè¯¥æ´»åŠ¨çš„ç‚¹èµæŒ‰é’®
                    syncLikeButtonForActivity(activityId, action === 'like');
                } else {
                    showMessage(result.error || 'æ“ä½œå¤±è´¥', 'error');
                    // æ¢å¤æŒ‰é’®çŠ¶æ€
                    syncLikeButtonForActivity(activityId, isCurrentlyLiked);
                }
            } catch (error) {
                console.error('ç‚¹èµæ“ä½œå¤±è´¥:', error);
                showMessage('ç½‘ç»œé”™è¯¯ï¼Œè¯·ç¨åé‡è¯•', 'error');
                // æ¢å¤æŒ‰é’®çŠ¶æ€
                syncLikeButtonForActivity(activityId, isCurrentlyLiked);
            }
        }

        // åŒæ­¥å•ä¸ªæ´»åŠ¨çš„ç‚¹èµæŒ‰é’®çŠ¶æ€
        function syncLikeButtonForActivity(activityId, isLiked) {
            const buttons = document.querySelectorAll(`[data-activity-id="${activityId}"] .like-btn`);
            buttons.forEach(button => {
                button.disabled = false;
                const likeCount = activityLikeCounts.get(activityId) || 0;
                if (isLiked) {
                    button.className = 'like-btn liked';
                    button.innerHTML = `â¤ï¸ å·²ç‚¹èµ ${likeCount > 0 ? `(${likeCount})` : ''}`;
                } else {
                    button.className = 'like-btn like';
                    button.innerHTML = `ğŸ¤ ç‚¹èµ ${likeCount > 0 ? `(${likeCount})` : ''}`;
                }
            });
        }

        // æ›´æ–°æ´»åŠ¨çš„ç‚¹èµæ•°é‡
        async function updateLikeCount(activityId) {
            try {
                const response = await fetchWithTimeout(`/api/activity/${activityId}/likes/count`);
                const result = await response.json();

                if (result.success) {
                    const likeCount = result.data.likeCount;
                    activityLikeCounts.set(activityId, likeCount);
                    
                    // æ›´æ–°æ‰€æœ‰è¯¥æ´»åŠ¨çš„ç‚¹èµæŒ‰é’®æ˜¾ç¤º
                    const isLiked = likedActivities.has(activityId);
                    syncLikeButtonForActivity(activityId, isLiked);
                }
            } catch (error) {
                console.error('æ›´æ–°ç‚¹èµæ•°é‡å¤±è´¥:', error);
            }
        }

        // æ£€æŸ¥å•ä¸ªæ´»åŠ¨çš„ç‚¹èµçŠ¶æ€
        async function checkLikeStatus(activityId) {
            if (!currentUserId) return false;

            try {
                const response = await fetchWithTimeout(`/api/user/${currentUserId}/like/${activityId}/status`);
                const result = await response.json();

                if (result.success) {
                    return result.data.isLiked;
                }
            } catch (error) {
                console.error('æ£€æŸ¥ç‚¹èµçŠ¶æ€å¤±è´¥:', error);
            }
            return false;
        }

        // åŠ è½½æ´»åŠ¨çš„ç‚¹èµçŠ¶æ€å’Œæ•°é‡
        async function loadLikeStatesForActivities(activities) {
            if (!currentUserId || !activities.length) return;

            try {
                // å¹¶è¡Œæ£€æŸ¥æ‰€æœ‰æ´»åŠ¨çš„ç‚¹èµçŠ¶æ€
                const likeStatusPromises = activities.map(async (activity) => {
                    const [isLiked, likeCountResponse] = await Promise.all([
                        checkLikeStatus(activity.id),
                        fetchWithTimeout(`/api/activity/${activity.id}/likes/count`)
                    ]);
                    
                    if (isLiked) {
                        likedActivities.add(activity.id);
                    }
                    
                    if (likeCountResponse.ok) {
                        const likeCountResult = await likeCountResponse.json();
                        if (likeCountResult.success) {
                            activityLikeCounts.set(activity.id, likeCountResult.data.likeCount);
                        }
                    }
                });

                await Promise.all(likeStatusPromises);
                console.log(`å·²åŠ è½½ ${activities.length} ä¸ªæ´»åŠ¨çš„ç‚¹èµçŠ¶æ€`);
            } catch (error) {
                console.error('åŠ è½½ç‚¹èµçŠ¶æ€å¤±è´¥:', error);
            }
        }

        // ==================== è¯„è®ºç›¸å…³åŠŸèƒ½ ====================

        // å­˜å‚¨è¯„è®ºæ•°æ®çš„Map
        const activityComments = new Map(); // activityId -> comments array
        const commentLikeStates = new Map(); // commentId -> boolean
        const commentLikeCounts = new Map(); // commentId -> number

        // åˆ‡æ¢è¯„è®ºåŒºåŸŸæ˜¾ç¤º/éšè—
        async function toggleComments(activityId) {
            const commentsSection = document.getElementById(`comments-${activityId}`);
            
            if (commentsSection.style.display === 'none') {
                commentsSection.style.display = 'block';
                // å¦‚æœè¯„è®ºè¿˜æ²¡æœ‰åŠ è½½è¿‡ï¼Œåˆ™åŠ è½½è¯„è®º
                if (!activityComments.has(activityId)) {
                    await loadComments(activityId);
                }
            } else {
                commentsSection.style.display = 'none';
            }
        }

        // åŠ è½½è¯„è®ºåˆ—è¡¨
        async function loadComments(activityId) {
            const commentsList = document.getElementById(`comments-list-${activityId}`);
            commentsList.innerHTML = '<div class="loading-comments">æ­£åœ¨åŠ è½½è¯„è®º...</div>';

            try {
                const response = await fetchWithTimeout(`/api/activity/${activityId}/comments?limit=20`);
                const result = await response.json();

                if (result.success) {
                    const comments = result.data.comments || [];
                    activityComments.set(activityId, comments);
                    
                    if (comments.length === 0) {
                        commentsList.innerHTML = '<div class="no-comments">æš‚æ— è¯„è®ºï¼Œå¿«æ¥å‘è¡¨ç¬¬ä¸€æ¡è¯„è®ºå§ï¼</div>';
                    } else {
                        await displayComments(activityId, comments);
                    }
                } else {
                    throw new Error(result.message || 'åŠ è½½è¯„è®ºå¤±è´¥');
                }
            } catch (error) {
                console.error('åŠ è½½è¯„è®ºå¤±è´¥:', error);
                commentsList.innerHTML = '<div class="no-comments">åŠ è½½è¯„è®ºå¤±è´¥ï¼Œè¯·ç¨åé‡è¯•</div>';
                showMessage(`åŠ è½½è¯„è®ºå¤±è´¥: ${error.message}`, 'error');
            }
        }

        // æ˜¾ç¤ºè¯„è®ºåˆ—è¡¨
        async function displayComments(activityId, comments) {
            const commentsList = document.getElementById(`comments-list-${activityId}`);
            
            // ä¸ºæ¯ä¸ªè¯„è®ºåŠ è½½ç‚¹èµçŠ¶æ€å’Œç‚¹èµæ•°
            await loadCommentLikeStates(comments);
            await loadCommentLikeCounts(comments);
            
            const commentsHtml = comments.map(comment => {
                const time = new Date(comment.created_at).toLocaleString('zh-CN');
                const authorId = comment.user?.id || comment.custom?.user_id || 'unknown';
                const isCurrentUser = authorId === currentUserId;
                const avatarLetter = authorId.charAt(0).toUpperCase();
                
                // æ£€æŸ¥è¯„è®ºç‚¹èµçŠ¶æ€
                const isLiked = commentLikeStates.get(comment.id) || false;
                const likeBtnClass = isLiked ? 'liked' : '';
                const likeBtnText = isLiked ? 'â¤ï¸' : 'ğŸ¤';
                
                // è·å–ç‚¹èµæ•°
                const likeCount = commentLikeCounts.get(comment.id) || 0;
                const likeCountText = likeCount > 0 ? ` (${likeCount})` : '';
                
                return `
                    <div class="comment-item" data-comment-id="${comment.id}">
                        <div class="comment-header">
                            <div class="comment-author">
                                <span class="user-avatar" style="display: inline-block; width: 20px; height: 20px; border-radius: 50%; background: #4facfe; color: white; text-align: center; line-height: 20px; font-size: 12px; margin-right: 8px;">${avatarLetter}</span>
                                ${authorId}
                            </div>
                            <div class="comment-time">${time}</div>
                        </div>
                        <div class="comment-content">${comment.text || 'æ— å†…å®¹'}</div>
                        <div class="comment-actions">
                            <button class="comment-like-btn ${likeBtnClass}" onclick="toggleCommentLike('${comment.id}', this)">
                                ${likeBtnText} ç‚¹èµ${likeCountText}
                            </button>
                            ${isCurrentUser ? `
                                <button class="comment-delete-btn" onclick="deleteComment('${comment.id}', '${activityId}')">
                                    ğŸ—‘ï¸ åˆ é™¤
                                </button>
                            ` : ''}
                        </div>
                    </div>
                `;
            }).join('');
            
            commentsList.innerHTML = commentsHtml;
        }

        // æäº¤è¯„è®º
        async function submitComment(activityId) {
            if (!currentUserId) {
                showMessage('è¯·å…ˆè®¾ç½®ç”¨æˆ·ID', 'error');
                return;
            }

            const commentsSection = document.getElementById(`comments-${activityId}`);
            const commentInput = commentsSection.querySelector('.comment-input');
            const submitBtn = commentsSection.querySelector('.comment-submit-btn');
            const comment = commentInput.value.trim();

            if (!comment) {
                showMessage('è¯·è¾“å…¥è¯„è®ºå†…å®¹', 'error');
                return;
            }

            try {
                submitBtn.disabled = true;
                submitBtn.textContent = 'å‘è¡¨ä¸­...';

                const response = await fetchWithTimeout(`/api/activity/${activityId}/comments`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        userId: currentUserId,
                        comment: comment
                    })
                });

                const result = await response.json();

                if (result.success) {
                    showMessage('è¯„è®ºå‘è¡¨æˆåŠŸï¼', 'success');
                    commentInput.value = '';
                    // é‡æ–°åŠ è½½è¯„è®ºåˆ—è¡¨
                    await loadComments(activityId);
                } else {
                    throw new Error(result.message || 'å‘è¡¨è¯„è®ºå¤±è´¥');
                }
            } catch (error) {
                console.error('å‘è¡¨è¯„è®ºå¤±è´¥:', error);
                showMessage(`å‘è¡¨è¯„è®ºå¤±è´¥: ${error.message}`, 'error');
            } finally {
                submitBtn.disabled = false;
                submitBtn.textContent = 'å‘è¡¨è¯„è®º';
            }
        }

        // åˆ é™¤è¯„è®º
        async function deleteComment(commentId, activityId) {
            if (!currentUserId) {
                showMessage('è¯·å…ˆè®¾ç½®ç”¨æˆ·ID', 'error');
                return;
            }

            if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡è¯„è®ºå—ï¼Ÿ')) {
                return;
            }

            try {
                const response = await fetchWithTimeout(`/api/comments/${commentId}`, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        userId: currentUserId
                    })
                });

                const result = await response.json();

                if (result.success) {
                    showMessage('è¯„è®ºåˆ é™¤æˆåŠŸï¼', 'success');
                    // é‡æ–°åŠ è½½è¯„è®ºåˆ—è¡¨
                    await loadComments(activityId);
                } else {
                    throw new Error(result.message || 'åˆ é™¤è¯„è®ºå¤±è´¥');
                }
            } catch (error) {
                console.error('åˆ é™¤è¯„è®ºå¤±è´¥:', error);
                showMessage(`åˆ é™¤è¯„è®ºå¤±è´¥: ${error.message}`, 'error');
            }
        }

        // è¯„è®ºç‚¹èµ/å–æ¶ˆç‚¹èµ
        async function toggleCommentLike(commentId, button) {
            if (!currentUserId) {
                showMessage('è¯·å…ˆè®¾ç½®ç”¨æˆ·ID', 'error');
                return;
            }

            const isLiked = commentLikeStates.get(commentId) || false;
            const originalText = button.textContent;
            
            try {
                button.disabled = true;
                button.textContent = isLiked ? 'å–æ¶ˆä¸­...' : 'ç‚¹èµä¸­...';

                const url = `/api/user/${currentUserId}/like/comment/${commentId}`;
                const method = isLiked ? 'DELETE' : 'POST';

                const response = await fetchWithTimeout(url, {
                    method: method,
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                const result = await response.json();

                if (result.success) {
                    // æ›´æ–°æœ¬åœ°çŠ¶æ€
                    commentLikeStates.set(commentId, !isLiked);
                    
                    // æ›´æ–°ç‚¹èµæ•°
                    const currentCount = commentLikeCounts.get(commentId) || 0;
                    const newCount = isLiked ? Math.max(0, currentCount - 1) : currentCount + 1;
                    commentLikeCounts.set(commentId, newCount);
                    
                    // æ›´æ–°æŒ‰é’®æ ·å¼å’Œæ–‡æœ¬
                    const likeCountText = newCount > 0 ? ` (${newCount})` : '';
                    if (!isLiked) {
                        button.classList.add('liked');
                        button.textContent = `â¤ï¸ ç‚¹èµ${likeCountText}`;
                    } else {
                        button.classList.remove('liked');
                        button.textContent = `ğŸ¤ ç‚¹èµ${likeCountText}`;
                    }
                    
                    showMessage(isLiked ? 'å–æ¶ˆç‚¹èµæˆåŠŸ' : 'ç‚¹èµæˆåŠŸ', 'success');
                } else {
                    throw new Error(result.message || 'æ“ä½œå¤±è´¥');
                }
            } catch (error) {
                console.error('è¯„è®ºç‚¹èµæ“ä½œå¤±è´¥:', error);
                showMessage(`æ“ä½œå¤±è´¥: ${error.message}`, 'error');
                button.textContent = originalText;
            } finally {
                button.disabled = false;
            }
        }

        // åŠ è½½è¯„è®ºçš„ç‚¹èµçŠ¶æ€
        async function loadCommentLikeStates(comments) {
            if (!currentUserId || !comments.length) return;

            try {
                const likeStatusPromises = comments.map(async (comment) => {
                    try {
                        const response = await fetchWithTimeout(`/api/user/${currentUserId}/like/comment/${comment.id}/status`);
                        const result = await response.json();
                        
                        if (result.success) {
                            commentLikeStates.set(comment.id, result.data.isLiked);
                        }
                    } catch (error) {
                        console.error(`æ£€æŸ¥è¯„è®º ${comment.id} ç‚¹èµçŠ¶æ€å¤±è´¥:`, error);
                    }
                });

                await Promise.all(likeStatusPromises);
                console.log(`å·²åŠ è½½ ${comments.length} æ¡è¯„è®ºçš„ç‚¹èµçŠ¶æ€`);
            } catch (error) {
                console.error('åŠ è½½è¯„è®ºç‚¹èµçŠ¶æ€å¤±è´¥:', error);
            }
        }

        // åŠ è½½è¯„è®ºçš„ç‚¹èµæ•°
        async function loadCommentLikeCounts(comments) {
            if (!comments.length) return;

            try {
                const likeCountPromises = comments.map(async (comment) => {
                    try {
                        const response = await fetchWithTimeout(`/api/comment/${comment.id}/likes/count`);
                        const result = await response.json();
                        
                        if (result.success) {
                            commentLikeCounts.set(comment.id, result.data.likeCount);
                        }
                    } catch (error) {
                        console.error(`è·å–è¯„è®º ${comment.id} ç‚¹èµæ•°å¤±è´¥:`, error);
                    }
                });

                await Promise.all(likeCountPromises);
                console.log(`å·²åŠ è½½ ${comments.length} æ¡è¯„è®ºçš„ç‚¹èµæ•°`);
            } catch (error) {
                console.error('åŠ è½½è¯„è®ºç‚¹èµæ•°å¤±è´¥:', error);
            }
        }
    </script>
</body>
</html>